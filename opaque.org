OPAQUEification of SPHINX

SPHINX is a beautiful protocol for password storage querying and
inserting of one password.

However in a real-life scenario users might want to store more than
one password, or sometimes even want to change the password or delete
it, users might have more than one account at a site and users do not
want to remember the list of user names, nor do they want to
synchronize them over all of their devices, users also want to store
various secrets in a password store that are not arbitrary passwords
that can be generated by SPHINX but tokens that are provided from the
outside. These are things that SPHINX does not provide.

However OPAQUE is quite magical, it contains a SPHINX at its core. In
OPAQUE SPHINX is used to derive a encryption key that is used to
decrypt an encrypted blob stored at the OPAQUE server. This encrypted
blob contains long-term key material, but it can also contain
additional sensitive data, which is exactly what we need. Furthermore
OPAQUE also provides us with a means to authenticate to the server so
that we can authorize deletion or changes of existing passwords.

Let's recap how SPHINX works and how this is used in OPAQUE:
  1. the user hashes his password and then blinds it: blindedpwhash = (hash(pwd)^blindingfacator)
  2. the server has a seed which it contributes into the blinded hash of the users password: blindedpwhash^seed
  3. the user unblinds the servers output, which results in hash(pwd)^seed

Setting up an OPAQUE session

OPAQUE extends this slightly:
  1. in step 1 the user also generates a one-time keypair [Xu, xu],
     The user sends the public part Xu along with the blinded
     password.
  2. in step 2 the server also generates a one-time keypair [Xs,
     xs]. The server now can generate the shared secret using its own
     and the users Long-term and One-time keys. Using this shared
     secret it can calculate an authentication token. The server also
     has the encrypted blob of the user, which together with its
     public one-time key Xs, the authentication token and the
     updated blinded hash is sent back to the user.
  3. The user uses the result from step 3 of the SPHINX protocol to
     decrypt the encrypted blob sent from the server in OPAQUE
     step 2. The users now has access to its own long-term keys,
     combining these with the one-time keys and the long-term and
     one-time public keys from the server it can also calculate the
     same shared secret that the server also calculated in 2. using
     this shared secret the user can calculate the same authentication
     token and verify if the server is correct. If needed the user can
     also calculate its own authentication token which can be sent to
     the server which can then authenticate the user, this is explicit
     authentication. It is also possible to do implicit
     authentication, by using the shared secret for encrypted
     communication with the server, and if that succeeds, the user is
     also authenticated to the server.

To use OPAQUE in the password storage use-case, the user can derive
the password from the key that was used to decrypt the blob containing
his long-term key material. This derivation must be based on a derived
key, not directly, otherwise the site where we use the password would
be able to decrypt the blob themselves if that somehow
leaks. Furthermore the encrypted blob can also contain information
about password rules, like maximum length, or forbidden character
classes, which otherwise need to be stored somewhere and might need to
be synchronized otherwise between differend devices of the user.

a bit more formally the setup of a session flow looks like this:

User:   pwd -> (r, alpha=hash(pwd)^r, Xu, xu), where r is the blinding factor,
                                               and alpha is the blinded password,
                                               [Xu,xu] is the pub/sec user ephemeral key

Server: (k, alpha, Xu, Pu, ps, xs) -> (blob, Pu, ps, k = load(),  # k is seed,
                                                                  # Pu is the users long-term pubkey,
                                                                  # ps is the servers long-term private key
                                       beta=alpha^k,
                                       [Xs, xs] = keygen(),       # the pub/sec ephemeral serverkey,
                                       Ks = 3dh(Xu,Pu,xs,ps),     # Ks is the shared secret
                                       auth = keyedhash(Ks,1))

User:   (pwd, r, beta, blob, Xs, auth) -> (K = hash(pwd||beta^-r),
                                           (Pu,pu,Ps,extra) = authDec(K, blob),
                                           Ku=3dh(pu, >xu, Ps, Xs),
                                           if auth!=keyedhash(Ku,1) abort)

Storage of "records"

The user does not have to store anything in this setup, all the user
needs is its password. However the server needs to store it's own
long-term keys and the encrypted blob somewhere, as long as there is
only one such there's not much to talk about. But as soon as there is
more such "records" we need to refer to them, a user needs to specify
somehow which long-term key material and blob it wants to access. To
avoid storing (and synching) these ids, it makes sense to have them
generated. In this Opaqueified SPHINX we use a keyed hash to create
ids that are non-reversible:

       id = hash(user||host, salt)

The user sends this id along with the first request so the server can
access the correct "record". Unfortunately this id is static and
allows an passive MitM attacker to infer statistical information about
accounts. To mitigate the server has one global keypair, that can be
used to encrypt the data in the first step of the
protocol. Unfortunately the server itself will still be able to
collect usage statistics on the key. This is something that also
plagues the original SPHINX protocol, which neglects the aspect of
serving multiple users.

User state

Although in a pure implementation of the SPHINX protocol there is no
state needed to be stored by the user. However in a multiuser setting
the user needs to know the global encryption key of the server and the
user also needs to store the salt to generate the record
ids. Fortunately this information only needs to be synched once to
each of the users devices.

Setup of records

We have described how to use OPAQUE in a SPHINX setting, but we have
not defined, how to setup a new record for such usage. Unfortunately
the original OPAQUE paper only defines a setup protocol where the
server sees all the sensitive data of the user, this might be
reasonable for enterprise settings, but not for a password storage
that should hide info even from itself (TM). It is however quite easy
to split up the setup protocol between the user and the server in a
way that does not disclose any sensitive material with the server. The
following 4 messages are exchanged:

 1. the user does what he would do in a normal sphinx protocol, he
    blinds his hashed password and sends it to the server.
 2. the server generates a random seed that it will contribute
    according to the SPHINX protocol to the blinded password, the
    server also generates a long-term keypair. The server keeps k, the
    private long-term key for the last step of this protocol, and
    sends the long-term public key and the blinded password with its
    contribution (beta) back to the user.
 3. The user generates a long-term keypair, unblinds beta, just as in
    the SPHINX protocol, it uses this to encrypt the long-term
    keypair, the servers long-term public key, and any extra data.
    The user sends back the enrypted blob and its long-term public key
    to the server.
 4. The server saves it's own long-term keypair, the seed, the users
    long-term public key, and the encrypted blob under the id provided
    by the user.

Formally:

create:
U: pwd -> (r, alpha=hash(pwd)^r), where r is the blinding factor,
                                  and alpha is the blinded password
S: alpha -> (Ps, ps, k, beta=alpha^k), where Ps, ps: pub/sec long-term server keypair,
                                       k: server seed to sphinx protocol,
                                       beta: k contributed to the blinded password alpha
U: (pwd, r, beta, Ps) -> (K = hash(pwd||beta^-r), blob = authENC(K, (Pu,pu,Ps, extra)))
S: store(record_id, ps,Ps,Pu,k,blob)

Management of records

Deletion of keys

So far we have only discussed use-cases that were covered by the pure
SPHINX and OPAQUE protocols. Deletion is not covered, the issue with
deletion is how to authorize someone to allow deletion of
"records". SPHINX itself does not provide any mechanism for
this. OPAQUE however contains authentication of both parties, we can
use a normal OPAQUE flow to authenticate deletion of records.

formally we first execute a session flow, like described above then:
User: Ks = 3dh(Xs,Ps,xu,pu), auth = keyedhash(Ks, 2)
Server: if keyedhash(Ks,2) == auth: deletes record, response = authenc(Ks,"ok") | "fail"
U: authdec(Ks,response)

Changing of passwords

If there is a need to change the password for a service, this is quite
easy, the only thing we need to do in the SPHINX protocol is to
generate a new seed on the server which will result in a new output of
the SPHINX protocol. However in the OPAQUE protocol this means we also
need to reencrypt the blob stored by the server with this new key.

more formally we first execute a session flow like described in the beginning then we:
User:   Ku = 3dh(Xs,Ps,xu,pu), r, alpha = hash(pwd)^r, auth = keyedhash(Ku, 2)
Server: alpha, auth -> if keyedhash(Ks, 2) == auth, generate new seed k, beta=alpha^k, where
                                   Ks is the shared secret calculated by the server during the session flow.
User    (pwd, r, beta, Ps) -> (K = hash(pwd||beta^-r), blob = authENC(K, (Pu,pu,Ps, extra)))
Server  store(ps,Ps,Pu,k,blob) into new location

Commit

To allow for errors during the changing of passwords on a service, the
old password is still active until the user commits the change, which
effectively replaces the old record with the new one. This is a simple
flow, it starts like all the other management flows with the session
flow which is used to authenticate the user to the server and if that
succeeds the server replaces the old record.

formally first we first initiate a session, then
User: Ku = 3dh(Xs,Ps,xu,pu), auth = keyedhash(Ku, 2)
Server: if auth==keyedhash(Ks, 2)replaces previous (ps,Ps,Pu,k,blob) with new, deletes previous

Weaknesses

1. the server can correlate which records belong to the same user and target server.
2. the servers long-term keypair is unencrypted on disk.
3. the servers global keypair is unencrypted on disk.
4. fail messages are unauthenticated/protected.
5. no refreshing of server long-term keys when changeing seed
