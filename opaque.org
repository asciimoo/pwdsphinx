* OPAQUification of SPHINX

SPHINX is a beautiful protocol for password storage querying and
inserting of one password.

However in a real-life scenario users might want to store more than
one password, or sometimes even want to change the password or delete
it, users might have more than one account at a site and users do not
want to remember the list of user names, nor do they want to
synchronize them over all of their devices, users also want to store
various secrets in a password store that are not arbitrary passwords
which can be generated by SPHINX but tokens that are provided from the
outside. These are things that SPHINX does not provide.

However OPAQUE is quite magical, it contains a SPHINX at its core. In
OPAQUE SPHINX is used to derive a encryption key that is used to
decrypt an encrypted blob stored at the OPAQUE server. This encrypted
blob contains long-term key material, but it can also contain
additional sensitive data, which is exactly what we need. Furthermore
OPAQUE also provides us with a means to authenticate to the server so
that we can authorize deletion or changes of existing passwords.

** Terminology
*** Records
Records are data structures stored at the password management server
which contain all the necessary information to provide a user with
means to store and query passwords.
*** User
User is the human attempting to manage its passwords.
*** Service
A service is some interface where the user wants to login.
*** Account
An account is a combination of a username and a password.
*** Account password
An account password is the password that authenticates the user with a
service.
*** rwd (Random word)
High-entropy password, derived from the SPHINX key in a way that makes
the output compatible with the password rules mandated by the service.
*** SPHINX key
High entropy 32 bytes derived from the SPHINX protocol by calculating:
hash(pwd||hash(pwd)^k), where k is a seed contributed the the password
manager.
*** Master Password
The master password is the password which is used in SPHINX to query
and derive the account password for a service. Unlike other password
managers it is possible with sphinx to have multiple master passwords,
since they are not used to open an encrypted database but only
contribute to the derivation of the account password.
*** Core functions
The two core functions that are defined by SPHINX are initialize SPHINX
record and query SPHINX.
*** Initialize SPHINX record
This core SPHINX function creates new record at the server for later
usage, this is what you want to run when registering a new users at a
service.
*** Query SPHINX
This core SPHINX function queries the SPHINX server (oracle) which has
an associated record previously setup by the other SPHINX core
function Initialize SPHINX record.
*** Management functions
A password manager has other functions besides creating and querying
them, such functions are deletion of accounts, changing of account
passwords or querying of other secrets stored in the encrypted OPAQUE
blob.

** Querying the SPHINX
Let's recap how SPHINX works and how this is used in OPAQUE:
  1. the user hashes his password and then blinds it:
     blindedpwhash = (hash(pwd)^blindingfacator)
     (we refer to the blinded hash later in this document as alpha)
  2. the server has a seed which it contributes into the blinded hash
     of the users password: blindedpwhash^seed
     (later in this document we refer to this value as beta)
  3. the user unblinds the servers output (beta) and hashes it again
     with the master password, which results in the SPHINX key
     K = hash(pwd,hash(pwd)^seed)

** Setting up an OPAQUE session

OPAQUE extends this slightly:
  1. in step 1 the user also generates a one-time key-pair [Xu, xu],
     The user sends the public part Xu along with the blinded
     password (alpha).
  2. in step 2 the server also generates a one-time key-pair [Xs,
     xs]. The server now can generate the shared secret using its own
     [xs, ps] and the users Long-term and One-time keys [Pu,
     Xu]. Using this shared secret it can calculate an authentication
     token. The server also has the encrypted blob of the user, which
     together with its public one-time key Xs, the authentication
     token and the updated blinded hash (beta) is sent back to the
     user.
  3. The user uses the SPHINX key K from step 3 of the
     SPHINX protocol to decrypt the encrypted blob sent from the
     server in OPAQUE step 2. The users now has access to its own
     long-term keys, combining these with the one-time keys and the
     long-term and one-time public keys from the server it can also
     calculate the same shared secret that the server also calculated
     in 2. using this shared secret the user can calculate the same
     authentication token and verify if the server is correct. If
     needed the user can also calculate its own authentication token
     which can be sent to the server which can then authenticate the
     user, this is explicit authentication. It is also possible to do
     implicit authentication, by using the shared secret for encrypted
     communication with the server, and if that succeeds, the user is
     also authenticated to the server.

To use OPAQUE in the password storage use-case, the user can derive
the password from the SPHINX key K which was the result of step 3 of
the SPHINX protocol. It is important that we cannot use K directly we
must derive the password from K with a KDF (key derivation function),
otherwise the site where we use the password would be able to decrypt
the blob themselves if that somehow leaks. Furthermore the encrypted
blob can also contain information about password rules, like maximum
length, or forbidden character classes, which otherwise need to be
stored somewhere and might need to be synchronized otherwise between
different devices of the user.

A bit more formally the setup of a session flow looks like this:

#+BEGIN_EXAMPLE
User:   recid = hash(user||host, salt)   # record id
        r,                               # r is the blinding factor,
        alpha=hash(pwd)^r,               # and alpha is the blinded password,
        [Xu, xu]),                       # [Xu,xu] is the pub/sec user ephemeral key

Server: blob, Pu, ps, k = load(recid),   # k is the seed,
                                         # Pu is the users long-term pubkey,
                                         # ps is the servers long-term private key
        beta=alpha^k,
        [Xs, xs] = keygen(),             # the pub/sec ephemeral server-key,
        Ks = 3dh(Xu,Pu,xs,ps),           # Ks is the shared secret
        auth = keyedhash(Ks,1))          # authentication token

User:   K = hash(pwd||beta^-r),          # the SPHINX key
        (Pu,pu,Ps,extra) = authDec(K, blob),
        Ku=3dh(pu, xu, Ps, Xs),          # Ks is the shared secret
        if auth!=keyedhash(Ku,1) abort
#+END_EXAMPLE

** Storage of "records"

The user does not have to store anything in this setup, all the user
needs is its password. However the server needs to store it's own
long-term keys and the encrypted blob somewhere, as long as there is
only one such there's not much to talk about. But as soon as there is
more such "records" we need to refer to them, a user needs to specify
somehow which long-term key material and blob it wants to access. To
avoid storing (and syncing) these ids, it makes sense to have them
generated. In this Opaqueified SPHINX we use a keyed hash to create
ids that are non-reversible:

#+BEGIN_EXAMPLE
       id = hash(user||host, salt)
#+END_EXAMPLE

The user sends this id along with the first request so the server can
access the correct "record". The salt is necessary to prohibit
pre-computation dictionary attacks against these ids. Unfortunately
this id is static and allows an passive MitM attacker to infer
statistical information about accounts. To mitigate the server has one
global key-pair (Gs,gs) for which the public key is publicly
known. This global key can be used to encrypt the data in the first
step of the protocol. Unfortunately the server itself will still be
able to collect usage statistics on the records. This is something
that also plagues the original SPHINX protocol.

Formally, this changes the first message sent from the user to the
server like this:
#+BEGIN_EXAMPLE
    Ys,ys = genkey()                                    # one-time key pair
    nonce||authenc((op,recid||message), nonce, Gs, ys)  # recid+msg encrypted with servers global key.
                                                        # op is the type of operation: CREATE/GET/CHANGE/COMMIT/DELETE
#+END_EXAMPLE

** User state

Although in a pure implementation of the SPHINX protocol there is no
state needed to be stored by the user. However in a multi-user setting
the user needs to know the global encryption key of the server and the
user also needs to store the salt to generate the record
ids. Fortunately this information only needs to be synced once to
each of the users devices. The global key can even be baked into
the client.

** Initialization of OPAQUE records

We have described how to use OPAQUE in a SPHINX setting, but we have
not defined, how to initialize a record for such usage. Unfortunately
the original OPAQUE paper only defines a setup protocol where the
server sees all the sensitive data of the user, this might be
reasonable for enterprise settings, but not for a password storage
that should hide info even from itself (TM). It is however quite easy
to split up the initialization protocol between the user and the
server in a way that does not disclose any sensitive material with the
server. The following 4 messages are exchanged:

 1. the user does what he would do in a normal sphinx protocol, he
    blinds his hashed password and sends it to the server.
 2. the server generates a random seed that it will contribute
    according to the SPHINX protocol to the blinded password, the
    server also generates a long-term keypair. The server keeps the
    seed k and the private long-term key (ps) for the last step of
    this protocol, and sends the long-term public key (Ps) and the
    blinded password with its contribution (beta) back to the user.
 3. The user generates a long-term keypair (Pu, pu), unblinds beta,
    hashes this with the password again to get the SPHINX key K just
    as in the SPHINX protocol. The user then uses K to encrypt the
    long-term keypair (Pu, pu), the servers long-term public key (Ps),
    and any extra data. The user sends back the encrypted blob and its
    long-term public key to the server.
 4. The server saves it's own long-term keypair (Ps, ps), the seed
    (k), the users long-term public key (Pu), and the encrypted blob
    under the id provided by the user.

Formally, the create flow looks like this:

#+BEGIN_EXAMPLE
User:   r,                               # r is the blinding factor,
        alpha=hash(pwd)^r),              # alpha is the blinded password

Server: (Ps, ps, k, beta=alpha^k),       # Ps, ps: pub/sec long-term server keypair,
                                           k: server seed to sphinx protocol,
                                           beta: k contributed to the blinded password alpha

User:   recid = hash(user||host, salt)   # record id
        K = hash(pwd||beta^-r),          # unblind and hash to get the SPHINX key
        blob = authENC(K, (Pu,pu,Ps, extra)))

Server: store(recid, (ps,Ps,Pu,k,blob))
#+END_EXAMPLE

** Management of records
Management functions change the records stored at the password
management server, these need to be somehow authenticated to prevent
denial of service for legitimate users.

*** Deletion of keys

So far we have only discussed use-cases that were covered by the pure
SPHINX and OPAQUE protocols. Deletion is not covered, the issue with
deletion is how to authorize someone to allow deletion of
"records". SPHINX itself does not provide any mechanism for
this. OPAQUE however contains authentication of both parties, we can
use a normal OPAQUE session flow authenticate deletion of records.

Formally we first execute the "Setting up an OPAQUE session" flow
then:

#+BEGIN_EXAMPLE
User: Ks = 3dh(Xs,Ps,xu,pu), auth = keyedhash(Ks, 2)    # user calculates shared secret and
                                                        # authentication token

Server: if keyedhash(Ks,2) == auth: delete(recid), response = authenc(Ks,"ok") | "fail"

User:   authdec(Ks,response)
#+END_EXAMPLE

*** Changing of passwords/records

If there is a need to change the password for a service, this is quite
easy, the only thing we need to do in the SPHINX protocol is to
generate a new seed on the server which will result in a new output of
the SPHINX protocol. However in the OPAQUE protocol this means we also
need to re-encrypt the blob stored by the server with the key derived
from this new seed and the master key. On an abstract level this means
first establishing an OPAQUE session to recover the contents of the
encrypted blob and to authenticate ourselves towards the server, and
then rerunning the OPAQUE record initialization.

More formally we first setup an OPAQUE session like described above,
then:

#+BEGIN_EXAMPLE
User:   Ku = 3dh(Xs,Ps,xu,pu),                  # user calculates shared secret and
        r, alpha = hash(pwd)^r,                 # fresh blinding of password a la SPHINX
        auth = keyedhash(Ku, 2)                 # authentication token

Server: if keyedhash(Ks, 2) != auth abort(),    # Ks is the shared secret calculated by the
                                                # server during the OPAQUE session setup flow.
        generate new seed k,                    # a la SPHINX
        beta=alpha^k,                           # a la SPINHX

User    (K = hash(pwd||beta^-r),                # unblind beta and hash to get the SPHINX key
        blob = authENC(K, (Pu,pu,Ps, extra)))   # re-encrypt blob

Server  store(recid, (ps,Ps,Pu,k,blob)) into 'new' location
#+END_EXAMPLE

*** Commit new record

To allow for errors during the changing of passwords on a service, the
old password is still active until the user commits the change, which
effectively replaces the current record with the new one. This is a
simple flow, it starts like all the other management flows with the
setup OPAQUE session flow which is used to authenticate the user to
the server and if that succeeds the server replaces the current
record.

formally first we first initiate a session, then
#+BEGIN_EXAMPLE
User: Ku = 3dh(Xs,Ps,xu,pu),   # shared secret
      auth = keyedhash(Ku, 2)  # authentication token
Server: if auth!=keyedhash(Ks, 2) abort()
        replace current (record_id, (ps,Ps,Pu,k,blob)) with 'new'
#+END_EXAMPLE

** OPAQUIFYING usernames
In a multi-device setting a password manager must provide means to
support multiple accounts for the same service for a user. If users
can remember all their accounts that is fine. But some users have many
accounts, some even generate random usernames. These need to be either
synced between the devices of a user (which is annoying) or these
username lists can be stored by the password manager. We can use the
OPAQUE encrypted blob stored on the server to maintain a list of user
accounts which can be queried by the devices of a user. The record id
for such OPAQUEified user-lists is simply hash(host,salt). We need to
handle two cases: when a new account is added to the password manager
and when an account is deleted from it, in both cases we need to
change the contents of the encrypted blob.

*** Adding a new user to the User-list record
When we store account names on the password manager and a new account
is created and a record added to the password manager we also need to
create or update the user list record as well. First we need to find
out if there is already a record for this service on the server, so we
have to setup an OPAQUE session with this record id, if it fails there
is no such record and we must create it, otherwise there is already a
record and we must update it. This can all be implemented by reusing
the previously defined primitives:

#+BEGIN_EXAMPLE
1. Setup OPAQUE session for recid=hash(host,salt)
2a. if 1. fails: Initialize OPAQUE record with extra="user"
2b. else: Change record, while appending "user" to extra blob, then Commit.
#+END_EXAMPLE

Since we don't use the SPHINX key K for authentication to a service it
is ok, to have it changed on every Change invocation.

*** Deleting a user from the User-list
When we use the password manager to store account user names in user
list records, and the user deletes an account we must remove the
account also from the associated user list record. This can be
implemented using the previously defined actions:

#+BEGIN_EXAMPLE
1. Setup OPAQUE session for recid=hash(host,salt)
2. remove user from encrypted blob
2a. if the encrypted blob is empty (this was the last user on this service), delete the record
2b. else: Change record using extra without the deleted user, then Commit.
#+END_EXAMPLE

Similarly to when we add a new user it is ok to have the seed changed
on every Change invocation, we don't use the SPHINX key K for
authentication to a service.

** Weaknesses

1. When using server side user-lists the server can correlate which
   records belong to the same user and target server.
2. The servers long-term key-pairs are unencrypted on disk.
3. The servers global keypair.
4. Fail messages are unauthenticated/protected.
5. No refreshing of server long-term keys when changing seed.
6. Initial messages encrypted with Gs are not forward-secure.
7. Leakage of the users salt allows pre-computation of record ids.
8. Per-user record long-term secret keys.
